name: Formatting your code
on:
  push:
    branches: master
  pull_request:
    types: [ opened, edited, reopened, synchronize ]
jobs:
  run_formatting:
    name: Run fix_formatting.py
    # clang-format has broken dependencies on ubuntu-latest
    runs-on: ubuntu-16.04
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Fetching branch info
      run: |
        if [ "${{ github.event_name }}" == "pull_request" ]
        then
          # In pull requests we need to figure out which branch in
          # which repo to check for changes from which commit
          set +e # grep will cancel curl after the first match
          u_sha=$(curl -i "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.number }}" | grep -m 1 "\"sha\": ")
          label=$(curl -i "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.number }}" | grep -m 1 "\"label\": ")
          set -e
          u_sha=${u_sha#*: \"}
          u_sha=${u_sha%\",}
          # I assume here that forks are always called "username/widelands"
          label=${label#*: \"}
          label=${label%\",}
          u_repo="${label%:*}/widelands"
          u_branch=${label#*:}
        else
          u_branch="${GITHUB_REF##*/}"
          u_repo="${{ github.repository }}"
          u_sha="$GITHUB_SHA"
        fi
        echo "${{ github.event_name }} event on branch '$u_branch' at repo '$u_repo', last commit '$u_sha'"
        echo "::set-env name=use_sha::$u_sha"
        echo "::set-env name=use_repo::$u_repo"
        echo "::set-env name=use_branch::$u_branch"
    - name: Installing python
      uses: actions/setup-python@v1
      with:
        python-version: 3.x
    - name: Installing formatting tools
      run: |
        sudo apt-get update
        sudo apt-get install clang-format
        pip install pyformat
    - name: Invoking fix_formatting.py
      run: python3 ./utils/fix_formatting.py
    - name: Gathering changes
      run: |
        nrfiles=$(git status -s | wc -l)
        if [ $nrfiles == 0 ]
        then
          echo "Nothing to do"
          FILES=""
        elif [ $nrfiles == 1 ]
        then
          echo "1 file formatted"
          nrfiles=$(git status -s)
          FILES="'${nrfiles#???}' was automatically formatted."
        else
          echo "$nrfiles files formatted"
          FILES="$nrfiles files were automatically formatted."
        fi
        echo "::set-env name=COMMIT_MESSAGE::$FILES"
    - name: Checking for remote updates
      run: |
        if [ -n "$COMMIT_MESSAGE" ]
        # skip if there's nothing to do
        then
          set +e
          latest=$(curl -i "https://api.github.com/repos/$use_repo/commits/$use_branch" | grep -m 1 "\"sha\": ")
          set -e
          latest=${latest#*: \"}
          latest=${latest%\",}
          if [ "$latest" == "$use_sha" ]
          then
            echo "No remote changes"
          else
            echo "The remote branch '$use_branch' from '$use_repo' was updated with '$latest' (we are on '$use_sha'), cancelling build"
            exit 1
          fi
        fi
      # In theory, a new push can hit the branch in this brief delay between check
      # and push. But this is such a narrow time window that it's unlikely.
      # If it does happen, the last step will most likely fail with a "branches
      # have diverged" error without affecting the newer push.
    - name: Committing and pushing changes
      run: |
        # copied from https://github.com/stefanzweifel/git-auto-commit-action/blob/master/entrypoint.sh
        cat <<- EOF > $HOME/.netrc
        machine github.com
        login $GITHUB_ACTOR
        password ${{ secrets.GITHUB_TOKEN }}
        machine api.github.com
        login $GITHUB_ACTOR
        password ${{ secrets.GITHUB_TOKEN }}
EOF
        chmod 600 $HOME/.netrc
        set -v #testing
        git remote add repo "git@github.com:$use_repo.git"
        git commit -m "$COMMIT_MESSAGE"
        git push repo "$use_branch"
